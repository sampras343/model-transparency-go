
# Fetch an OIDC token from the sigstore-conformance beacon with expiry validation.
# Re-fetches if the token has insufficient remaining lifetime. The beacon refreshes
# tokens on a ~10 min cron cycle, so we use a timeout-based approach to span at
# least one full refresh cycle.
# Args: $1=clone_dir  $2=token_file  [$3=timeout_secs]  [$4=min_lifetime_secs]
fetch_oidc_token() {
	local tokenproj="$1"
	local token_file="$2"
	local timeout="${3:-600}"       # 10 minutes â€” covers one full beacon refresh cycle
	local min_lifetime="${4:-30}"
	local start_time attempt
	start_time=$(date +%s)
	attempt=0

	while true; do
		attempt=$((attempt + 1))
		local now elapsed
		now=$(date +%s)
		elapsed=$((now - start_time))

		if [ "${elapsed}" -ge "${timeout}" ]; then
			echo "  Error: could not obtain a valid OIDC token within ${timeout}s (${attempt} attempts)"
			return 1
		fi

		rm -rf "${tokenproj}"
		mkdir -p "${tokenproj}"

		if ! git clone --quiet --single-branch --branch current-token --depth 1 \
			https://github.com/sigstore-conformance/extremely-dangerous-public-oidc-beacon \
			"${tokenproj}" 2>/dev/null; then
			echo "  Warning: git clone failed (attempt ${attempt}, ${elapsed}s elapsed)"
			sleep 10
			continue
		fi

		if [ ! -f "${token_file}" ]; then
			echo "  Warning: token file not found (attempt ${attempt}, ${elapsed}s elapsed)"
			sleep 10
			continue
		fi

		local token
		token=$(cat "${token_file}")

		# Decode JWT payload and check expiry (base64url -> base64)
		local payload exp
		payload=$(echo "${token}" | cut -d. -f2 | tr '_-' '/+' | base64 -d 2>/dev/null) || true
		exp=$(echo "${payload}" | jq -r '.exp // 0' 2>/dev/null) || true

		if [ -n "${exp}" ] && [ "${exp}" != "0" ] && [ "${exp}" != "null" ]; then
			local remaining
			now=$(date +%s)
			remaining=$((exp - now))

			if [ "${remaining}" -ge "${min_lifetime}" ]; then
				echo "  Token fetched (${remaining}s remaining, attempt ${attempt})"
				return 0
			fi
			echo "  Warning: token expires in ${remaining}s, need >=${min_lifetime}s (attempt ${attempt}, ${elapsed}s elapsed)"
		else
			echo "  Token fetched (expiry not parseable, using as-is)"
			return 0
		fi

		sleep 30   # wait for beacon to mint a fresh token
	done
}

# Sign with sigstore, retrying with a fresh OIDC token on each attempt.
# The token flag and value are appended to the end of the sign command.
# If the token fetch itself fails (beacon down), we bail immediately since
# retrying the sign won't help.
# Args: $1=clone_dir  $2=token_file  $3=token_flag  remaining args = sign command (without token flag)
# Example:
#   sigstore_sign_with_retry "$TOKENPROJ" "$TOKEN_FILE" "--identity-token" \
#       "$BINARY" sign sigstore --use-staging --signature "$SIG" "$MODEL"
sigstore_sign_with_retry() {
	local tokenproj="$1"
	local token_file="$2"
	local token_flag="$3"
	shift 3
	local max_attempts="${SIGSTORE_SIGN_MAX_RETRIES:-3}"
	local attempt

	for attempt in $(seq 1 "${max_attempts}"); do
		if ! fetch_oidc_token "${tokenproj}" "${token_file}"; then
			echo "  Error: OIDC beacon unavailable, cannot sign"
			return 1
		fi

		local token
		token=$(cat "${token_file}")

		if "$@" "${token_flag}" "${token}" 2>&1; then
			return 0
		fi

		echo "  Warning: sigstore sign failed (attempt ${attempt}/${max_attempts})"
		if [ "${attempt}" -lt "${max_attempts}" ]; then
			echo "  Retrying with fresh token..."
			sleep 5
		fi
	done

	echo "  Error: sigstore signing failed after ${max_attempts} attempts"
	return 1
}

# Get the list of files that were signed
get_signed_files()
{
	local sigfile="$1"

	jq -r .dsseEnvelope.payload < "${sigfile}" | \
		base64 -d | \
		jq -c '.predicate.resources | map(.name)'
}

# Check if bundle uses single certificate format (sigstore-go compatible)
has_single_certificate()
{
	local sigfile="$1"
	jq -e '.verificationMaterial.certificate != null' < "${sigfile}" > /dev/null 2>&1
}

# Check if bundle uses certificate chain format (custom)
has_certificate_chain()
{
	local sigfile="$1"
	jq -e '.verificationMaterial.x509CertificateChain != null' < "${sigfile}" > /dev/null 2>&1
}

# Get the number of certificates in the chain
get_certificate_count()
{
	local sigfile="$1"
	if has_certificate_chain "${sigfile}"; then
		jq '.verificationMaterial.x509CertificateChain.certificates | length' < "${sigfile}"
	elif has_single_certificate "${sigfile}"; then
		echo "1"
	else
		echo "0"
	fi
}

# Check bundle format and print info
check_bundle_format()
{
	local sigfile="$1"
	local expected_format="$2"  # "single" or "chain"

	if [ "${expected_format}" = "single" ]; then
		if ! has_single_certificate "${sigfile}"; then
			echo "Error: Expected single certificate format but got certificate chain"
			return 1
		fi
		echo "  Bundle format: single certificate (sigstore-go compatible)"
	elif [ "${expected_format}" = "chain" ]; then
		if ! has_certificate_chain "${sigfile}"; then
			echo "Error: Expected certificate chain format but got single certificate"
			return 1
		fi
		local count
		count=$(get_certificate_count "${sigfile}")
		echo "  Bundle format: certificate chain (${count} certificates)"
	else
		echo "Error: Unknown expected format: ${expected_format}"
		return 1
	fi
	return 0
}

# Get the name of the model from the subject
get_model_name()
{
	local sigfile="$1"

	jq -r .dsseEnvelope.payload < "${sigfile}" | \
		base64 -d | \
		jq -r '.subject[0].name'
}

check_model_name()
{
	local sigfile="$1"
	local exp="$2"

	local act

	act=$(get_model_name "${sigfile}")
	if [ "${act}" != "${exp}" ]; then
		echo "Error: Name of model in signature is wrong"
		echo "expected: ${exp}"
		echo "  actual: ${act}"
		exit 1
	fi
}
